---
title: 목 함수 (6)
author: JUNG YoungKyun
date: 2022-05-29
category: 01 jest
layout: post
---

![write date](https://img.shields.io/badge/write_date-2022_05_29-blue.svg)

자 이번 시간에 목 함수에 대해서 알아보겠습니다

목은 사전적인 의미로 모의의 가짜의 라는 의미를 가지고 있습니다
0:10
목업 이라는 표현도 잘 사용하는데 모형 모의 이런 뜻이죠
0:16
그러니까 목성 펑션 목 함수는 실제 함수를 구현한 것이 아니라 그저 흉내만 낸
0:21
그러니까 테스트하기 위해서 만든 일종의 모형 이라고 생각하시면
0:26
되겠습니다
0:27
예를 들어서 유저 db 에 접근해서 유저 리스트를 셀렉트 해오는 작업이
0:31
필요하다고 가정해 보겠습니다
0:33
일단 이 경우에 작성 해야 될 코드가 상당히 많아 지겠죠
0:37
이미 만들어져 있는 코드가 있던 상관 없겠지만 새로 만들게 된다면
0:40
테스트를 위한 코드 보다 어쩌면 더 길어질 수도 있습니다
0:45
그리고 저런 작업은 네트워크 환경이나 db의 상태 등 외부 요인에 의해
0:50
결과가 달라질 수 있습니다
0:51
테스트를 하기 위해서는 동일한 코트는 동일한 결과를 내야 겠죠
0:56
자 한번 사용해보겠습니다
1:01

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn();
mockFn(1);
```

`jset.fn()` 으로 목 함수를 만들 수 있습니다
1:04
이렇게 만들고 호출을 해 보겠습니다
1:11
이렇게 인수를 넘길 수도 있구요
1:14
이걸로 뭘 할 수 있을까요 이렇게 만든 목 함수에는 목이 라는 프로퍼티가
1:18
있는데 이 안에는 콜스 라는 배열이 있습니다 한번 찍어 볼게요

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn();
mockFn(1);

test('dd', () => {
  console.log(mockFn.mock.calls)
  expect('dd').toBe('dd');
});
```

1:23
의미없는 테스트라는 작사 하구요
1:30
이렇게 목 이라는 프로펄스 안에 콜 스가 있습니다
1:34
확인해 볼게요

`test`
```renderscript
# npm test

PASS ./fn.test.js
v dd ( 7 ms )

console.log
  [ [], [ 1 ] ]

Test Suites: 1 passed, 1 total
Tests: 1 passed, 1 total
Snapshot: 0 total
Time: 1.284 s
```

1:39
4 이런 배열이 나왔어요 여기서 목 함수의 강점이 잘 드러나는데

이 `.mock` 프로퍼티에는 호출되었던 어떤 값들이 고스란히 저장되어 있다는 점입니다
1:48
몇번 출 됐는지 어떤 인수가 전달 되었는지 알기 때문에 이를 활용할 수
1:53
있습니다
1:54
잘 calls 이걸로 알 수 있는 내용은 두 가지입니다 함수가 총 몇 번 호출
1:59
되었는가?
2:00
그리고 호출될 때 전달된 인수는 무엇인가? 작성을 한번 해볼게요
2:25

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn();
mockFn(1);

test('함수는 2번 호출됩니다.', () => {
  expect(mockFn.mock.calls.length).toBe(2);
});

test('2번째로 호출된 함수에 전달된 첫번째 인수는 1입니다.', () => {
  expect(mockFn.mock.calls[1][0]).toBe(1);
});
```

`calls`의 길이는 호출된 횟수 겠죠
2:29
그리고 이 배열 내부에는 전달된 인수의 값이 배열로 들어있습니다 방금
2:33
작성한 코드를 테스트 해보겠습니다

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 함수는 2번 호출됩니다. ( 7 ms )
v 2번째로 호출된 함수에 전달된 첫번째 인수는 1입니다. 

Test Suites: 1 passed, 1 total
Tests: 2 passed, 2 total
Snapshot: 0 total
Time: 0.864 s, estimated 1 s
```

둘 다 통과 했어요 

`fn.test.js`
```renderscript
const mockFn = jest.fn();

function forEachAdd1(arr) {
  arr.forEach(num => {
    mockFn(num + 1);
  });
}

forEachAdd1([10, 20, 30]);

test("함수 호출은 3번 됩니다.", () => {
  expect(mockFn.mock.calls.length).toBe(3);
});

test("전달된 값은 11, 21, 31 입니다.", () => {
  expect(mockFn.mock.calls[0][0]).toBe(11);
  expect(mockFn.mock.calls[1][0]).toBe(21);
  expect(mockFn.mock.calls[2][0]).toBe(31);
});
```

이렇게
2:45
숫자가 들어 있는 배열을 반복하면서 1 증가 시켜 준 값을 콜백 함수에
2:50
전달 해 주는 `forEachAdd1`이란 함수를 만들어보겠습니다

여기에 들어갈 함수는 아직 만들지 않았습니다 이럴 때 시간을 들여서
3:08
함수를 작성하지 말고 빠르고 간단한 테스트를 위해서 목 함수를 활용해
3:13
보겠습니다
3:18
이렇게 목 함수를 만들고
3:24
이렇게 콜백 함수로 전달을 해줍니다
3:31
실재 사용을 해보겠습니다

함수호출은 3번 되겟죠

전달된 값은 1씩 증가하는 값입니다

이렇게 만들고
4:08
테스트를 해보겠습니다

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 함수 호출은 3번 됩니다. ( 2 ms )
v 전달된 값은 11, 21, 31 입니다.
```

모두 통과 됐어요. 자 지금 이 콜백 함수를 굳이 새로 만들어서 전
4:18
달해 보지 않아도 목 함수 를 이용해서 `forEachAdd1`함수는 잘
4:22
동작한다는 걸 알 수 있죠
4:25


`fn.test.js`
```renderscript
const mockFn = jest.fn(num => num + 1);

mockFn(10);
mockFn(20);
mockFn(30);

test("함수 호출은 3번 됩니다.", () => {
  console.log(mockFn.mock.results);
  expect(mockFn.mock.calls.length).toBe(3);
});
```

이제 어떤 값을 리턴하는 함수가 필요하다고 합시다 숫자를 받아서
4:32
+1을 해주겠습니다
  4:35
  이렇게 test.fn 의 첫 번째 인수로 함수를 전달해줍니다 그리고
  4:40
  한번 호출해볼게요
  4:47
  마찬가지로 3번 호출 되겠죠 이번에는 result 라는 값을 한번 찍어
  4:51
  보겠습니다

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 함수 호출은 3번 됩니다.

console.log
  [
    { type: 'return', value: 11 },
    { type: 'return', value: 21 },
    { type: 'return', value: 31 },
  ]
```

  이 result 에는 리턴된 값이 배열로 들어있습니다 이렇게
  5:05
  1씩 증가된 값이 리턴된 걸 확인할 수 있습니다
  5:13

`fn.test.js`
```renderscript
const mockFn = jest.fn(num => num + 1);

mockFn(10);
mockFn(20);
mockFn(30);

test("10에서 1 증가한 값이 반환된다.", () => {
  expect(mockFn.mock.results[0].value).toBe(11);
});

test("20에서 1 증가한 값이 반환된다.", () => {
  expect(mockFn.mock.results[1].value).toBe(21);
});

test("30에서 1 증가한 값이 반환된다.", () => {
  expect(mockFn.mock.results[2].value).toBe(31);
});
```

  테스트 코드는 이렇게 작성할 수 있겠네요

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 10에서 1 증가한 값이 반환된다.
v 20에서 1 증가한 값이 반환된다.
v 30에서 1 증가한 값이 반환된다.
```

  테스트는 모두 통과 했죠
  5:39
  사용할 때 마다 각각 다른 값을 리턴해 줄 수도 있습니다

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn
  .mockReturnValueOnce(10)
  .mockReturnValueOnce(20)
  .mockReturnValueOnce(30)
  .mockReturnValue(40);
  
mockFn();
mockFn();
mockFn();
mockFn();

test("dd", () => {
  console.log(mockFn.mock.results);
  expect("dd").toBe("dd");
});
```

  5:43
  이때는 mockReturnValue 을 사용해 주는데요
  5:47
  중간을 리턴 값을 바꾸려는 once를 붙여 주면 됩니다
  5:56
  5
  5:59
  마지막으로 이렇게 once를 빼 주시구요
  6:06
  5
  6:08
  이렇게 한번 찍어 볼게요

`test`
```renderscript
# npm test

PASS ./fn.test.js
v dd

console.log
  [
    { type: 'return', value: 10 },
    { type: 'return', value: 20 },
    { type: 'return', value: 30 },
    { type: 'return', value: 40 }
  ]
```

  이렇게 나오자 확인해보면 10 20 30 40 이 리턴된걸 알 수
  6:25
  있습니다
  6:26
  이걸 활용해서 1부터 5까지 받아서
  6:29
  홀수 만 리턴하는 함수를 한번 작성해 보겠습니다

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn
  .mockReturnValueOnce(true)
  .mockReturnValueOnce(false)
  .mockReturnValueOnce(true)
  .mockReturnValueOnce(false)
  .mockReturnValue(true);
  
const result = [1, 2, 3, 4, 5].filter(num => mockFn(num));

test("홀수는 1,3,5", () => {
  expect(result).toStrictEqual([1, 3, 5]);
});
```

  네 이렇게 작성할 수 있겠죠 여기서 이 콜백 감수가 홀수 인지 짝수
  6:44
  인지 판별 해주는 역할을 해야 되는데 뭐 사실 굉장히 단순한 로직이긴 한데,
  지금 당장 코드를 만들 형편이 되지 않는다면 이 목 함수를 쓰는 거에요
  6:57
  목함수는 단순 true와 false를 번갈아가면서 리턴해 주도록 하겠습니다
  
  네 이렇게 적성 했구요
  
이렇게 배열을 확인할 때는 toBe()가 아니라 toStrictEqual()를 사용하셔야 됩니다
  7:37
  원래는 이 부분(num => mockFn(num))에 다가 홀수 인지 짝수 인지 판별해 줄 수 있는
  7:41
  함수를 작성을 해야 되는데
  7:43
  일단은 목 함수를 사용하고 어떤 숫자가 넘어오던지 그냥 순서대로 true false, true false 이렇게 번갈아 하면서 리턴을 해주고 있습니다
  7:51
  실행을 해보면 1 3 5만 이 부분이 true가 될 것이기 때문에 그래서 result는
  7:58
  135 가 될 겁니다 한번 해볼게요

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 홀수는 1,3,5 (1 ms)
```

잘 나오네요

목 함수 대신에 실제에 코트를 작성하시면 되겠습니다

  여기서 뭐 mockReturnValue로 말고

`fn.test.js`
```renderscript
const mockFn = jest.fn();

mockFn
  .mockResolvedValue({ name : "Mike" });
  
const result = [1, 2, 3, 4, 5].filter(num => mockFn(num));

test("받아온 이름은 Mike", () => {
  mockFn().then(res => {
    expect(res.name).toBe("Mike");  
  });
});
```

  mockResolvedValue로 사용하면 비동기 함수를 흉내낼수도 있습니다

  이렇게 작성할 수 있겠죠

`test`
```renderscript
# npm test

PASS ./fn.test.js
v 받아온 이름은 Mike
```

  네 이렇게 비동기 함수 처럼 then()을 이용해서 여기서 리턴해 주는 값을 비교해
  8:57
  볼 수 있습니다



  이번에는 이렇게 여기에 있는 외부 코드를 활용한 테스트가 필요하다고 가정을 해보겠습니다

`fn.js`
```renderscript
const fn = {
  add: (num1, num2) => num1 + num2,
  connectUserDb : () => {
    return new Promise(res => {
      setTimeout(() => {
        res({
          name: "Mike",
          age: 30,
          gender: "male",
        });
      }, 500);
    });
  },
  disconnectDb: () => {
    return new Promise(res => {
      setTimeout(() => {
        res();
      }, 500);
    });
  },
  connectCarDb : () => {
    return new Promise(res => {
      setTimeout(() => {
        res({
          brand: "bmw",
          name: "z4",
          color: "red",
        });
      }, 500);
    });
  },
  disconnectCarDb: () => {
    return new Promise(res => {
      setTimeout(() => {
        res();
      }, 500);
    });
  }
};

module.exports = fn;
```

  어 유저를 생성하는 코드를 테스트 해보고 싶은데 테스트할 테마다 실제로
  9:13
  유저가 생겨 버리면 곤란하겠죠
  9:15
  그렇다고 테스트가 끝날 때마다 로 빼게 해주는 것도 상당히 번거로울
  9:19
  겁니다
  9:20
  이럴 때는 뭐 킥 모듈이 라는 것을 쓰면 됩니다
  9:23
  게다가
  9:26
  올 안아 드릴께요 5
  9:30
  실제로 하며 가능했습니다
  9:38
  이렇게 이름을 가 자서 유저 객체를 리턴 해주는 함수 라라 만들었습니다
  9:42
  실제로는 유저 db 에 이 절을 생성해 주는 함수 라고 가정을 하겠습니다
  9:47
  일제 한번 사용을 해 볼게요
  9:51
  아
  9:53
  5
  10:02
  5
  10:05
  아
  10:09
  이렇게 사용 하겠죠
  10:13
  4 테스트를 통과 있고 실제로 유저가 생겨버렸습니다 이런 경우 다시 db
  10:18
  접속 에서 방금 만든 테스트 이제는 삭제 해야 되겠죠
  10:22
  이럴때
  10:26
  목 이런걸 사용합니다
  10:29
  그리고
  10:37
  쥬트 점 목으로 efn l 모 캑 모듈로 만들어 줍니다
  10:42
  이제 sna 크레듀 절을 사용할 텐데 뭐 1턴 밸류를 통해서 2세 체를
  10:48
  l 하도록 하겠습니다
  10:50
  이렇게 작성하면 실제 fm 점 크레이들 2 저는 호출되지 않습니다
  10:55
  상황이 객체를 반환 해주는 목 함수가 동작할 뿐이에요 실행을 한번 해보면
  11:02
  테스트는 통과했고 아까 보였던 오군은 지키지 않습니다
  11:06
  실제 유적을 생성 되지는 않았다는 거죠
  11:13
  1 2를 주석처리 하고 실행을 하면
  11:18
  4 이렇게 실제 사용자가 생성이 되는데 이렇게 뭐 캑 모주 를 이용하면
  11:30
  실제 를 위한 수 가 동작하지 않습니다
  11:33
  시체 1 기어가 생성 되지는 않았다는 거죠
  11:37
  마지막으로 유용한 매체들 나까지 소개해 드리고 마치겠습니다
  11:40
  이토 b couldn't 은 한 번이라도 호출 됐으면 본가 됩니다
  11:45
  2b 콜트 타임스는 정확한 호출 횟수를 의미합니다
  11:50
  지금 3과 노출 됐기 때문에 사람이 되겠죠
  11:53
  2b 콜드 u 드는 인수로 어떤 값들을 가던 새 카고 라스트 콜 드
  11:59
  일드는 인수를 체크하는 건 동일하지만 마지막으로 실행된 함수의 인수 만
  12:03
  체크합니다 돌려보면
  12:07
  4 모두 통과 하 죠 2b 콜드 빌드에
  12:11
  일부분을 32 랑 40 으로 바꿔도
  12:16
  통과하게 됩니다
  12:19
  하지만 이 부분을 10이라는 20으로 꾸면
  12:26
  실패하게 되죠 마지막은 30과 40 을 전달 했기 때문입니다
  12:31
  4 이번시간은 목 함수에 대해서 알아봤습니다
  12:34
  특정 기능의 집중하는 가짜 암수를 적재를 활용하면서 효율적인 코딩 및
  12:39
  테스트 진행하시길 바랍니다
  12:42
  마쳐 있습니다 감사합니다