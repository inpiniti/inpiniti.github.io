---
title: 헤드 퍼스트 디자인 패턴
author: JUNG YoungKyun
date: 2022-07-20
category: 18 book
layout: post
---

![헤드 퍼스트 디자인 패턴](../images/18 book/04 헤드 퍼스트 디자인 패턴/헤드퍼스트 디자인패턴.jpg)

|도서명|[헤드퍼스트 디자인패턴](https://www.hanbit.co.kr/store/books/look.php?p_code=B6113501223)|
|---|---|
|지은이|에릭 프리먼, 엘리자베스 롭슨|
|옮김|서환수|
|출판사|한빛미디어|
|ISBN|9791162245262|
|금액|36,000원|
|출판일|2022년 03월 16일 발행(개정판)|
|페이지수|656쪽|
|참고|Sungho's Blog[Head First Design Patterns](https://sgc109.github.io/2020/07/19/head-first-design-patterns/)|

# 디자인 패턴을 알아야 하는 이유
- 보통 소프트웨어를 유지 및 보수하는 데는 소프트웨어를 개발하는 만큼의, 혹은 더 많은 양의 비용과 노력이 들기 때문에 확장성, 혹은 유지 보수성은 매우 중요하다.
- 디자인 패턴을 잘 활용하면 확장성있는 **유연한 소프트웨어를 작성하는데 도움이 된다.**
- 또한, 디자인 패턴을 알면 다른 개발자와 소프트웨어의 설계에 대해 이야기 할 때 장황한 설명 없이 특정 패턴의 이름을 말하는 것만으로도
어떤 구조를 말하는 건지 **의도를 빠르고 명확하게 전달할 수 있다**는 점에서 커뮤니케이션 실수를 줄이고 생산성을 높이는데 큰 도움이 된다.
- 게다가 이미 존재하는 수많은 복잡한 시스템이나 프레임 워크, 혹은 API 들은 대부분 디자인 패턴을 활용하여 작성 되었다.
- 그렇기 때문에 디자인 패턴을 알면 소스 코드를 조금만 훑어봐도 어떤 패턴을 사용하여 구현된건지 금방 눈치 챌 수 있어 **큰 그림을 이해하는데 도움이 된다.**

# 자주 쓰이는 디자인 패턴 15가지
## Strategy 패턴

- 오리 시뮬레이션 게임 구현하기
    - 방법 1 (only 상속)
        ![image](https://user-images.githubusercontent.com/7943694/75551365-675d5780-5a77-11ea-8278-2f0c8dbdd635.png)
        - Duck 이라는 슈퍼 클래스를 만들고 꽥꽥대기(quack), 수영하기(swim) 등의 공통된 행위를 메소드로 정의한다. 
        - 오리의 종류에 따라 화면에 표시하는 방식이 다르므로 display 라는 추상 메소드를 둔다. 
        - 다양한 오리의 클래스들이 Duck 클래스를 상속받아 각자의 기능을 정의한다. 
        - 하지만 만약 오리에 나는 기능을 추가하기위해 날기(fly) 라는 새로운 행위를 메소드로 정의한다면 잠재적인 문제가 발생한다. 
        - 일부 서부클래스들은 슈퍼클래스의 일부, 혹은 전체 행위를 할 수 없어야 하는 경우다. 예를 들어, *장난감 오리* 를 나타내는 *RubberDuck* 이라는 서브클래스는 날면 안되기 때문에 *fly* 메소드를 오버라이딩하여 아무것도 하지않도록 해야하며, *나무를 깎아 만든 오리장식* 을 나타내는 *DecoyDuck* 라는 서브클래스는 나는것은 물론 꽥꽥대지도 말아야하기 때문에 *fly* 와 *quack* 메소드 모두 오버라이드 하여 아무 행위도 하지않도록 해야한다. 즉, **재사용을 목적으로 상속을 사용하는 것은 좋지만,  maintenance 측면에서는 그다지 좋지 않다는 것이다**
    
    - 방법 2 (+ interface)
        ![image](https://user-images.githubusercontent.com/7943694/75551297-3aa94000-5a77-11ea-8947-dd5d9d2c2b74.png)
        - 그렇다면 Interface 는 어떨까?
        - display 나 swim 같은 공통된 성질 및 행위는 Duck 이라는 슈퍼클래스에 두고 상속받도록 하되, fly, quack 등의 optional한 behavior 는 interface 로 정의하고, 각각의 오리 subclass 들이 필요한 behavior 를 impplements 하여 스스로 각자의 기능을 정의하도록 하는 방법이다. 
        - **필요한 행위만 골라** 쓸 수 있다는 점은 분명 장점이지만, 행위 코드의 **재사용**이 불가능해지기때문에 **코드의 중복**이 발생한다. 
        - 만약, fly 라는 행위에 대한 요구사항이 조금이라도 발생한다면, 이를 구현하고있는 **모든 subclass 들의 코드들을 모두 변경해주어야** 한다는 문제도 있다. 
        - 결국 이 방식은 이전의 inheritance 를 사용한 방식의 일부 문제는 해결주지만 코드 재사용의 이점을 없애 또다른 maintenance nightmare 를 만든다.
    
        - **여기서 중요한 법칙이 나온다.** 프로그래밍을 할 때 절대 변하지 않는 법칙은, 프로그램은 항상 **변한다**는것이다. 규모가 커지거나 기능이 변경될 수가 있다는 것이다.
        그러므로 변하는 부분을 **Encapsulation(캡슐화)** 하여 변하지 않는 부분으로 부터 분리해야한다. 그러면 분리한 부분이 다른 것으로 대체되거나 확장되어도 변하지 않는 부분에 영향을 끼치지 않게 된다. (SOLID 의 OCP 와도 일맥상통한다) 결과적으로 코드 변경 시 의도치않은 결과가 줄고, 유연함이 생긴다.
    
    - 방법 3 (Strategy Pattern)
        ![image](https://user-images.githubusercontent.com/7943694/75566420-fa57bb00-5a92-11ea-94f9-cf561a19dc3c.png)
    
        - 그렇다면, optional 한 behavior 들을 캡슐화하여 오리 subclass 를 생성할 때 행위를 정의해 줄 수는 없을까?
        - 행위들을 interface 로 정의하고, 이를 implements 하는 구체적인 행위들을 정의한뒤, setter method 를 통해 초기화 해준다. 
        - 여기서 또다른 Design Principal 이 등장하는데, behavior 를 전달받는 오리 class에서 behavior 의 type 을 구체적인(인터페이스를 구현하는 클래스)타입이 아니라 인터페이스의 타입으로 사용하는 것이다. 
        - 이렇게되면 런타임에 행위를 다른 것으로 동적으로 변경해줄 수도 있게된다.
        - 오리 클래스는 행위의 구체적인 구현을 알 필요가 없어진다.
        - 이 원칙은 **Program to an interface, not an implementation** 이다.
        - 만약 행위를구체적인 타입으로 선언할 경우 변경에 대한 여지가 사라지게 된다.
        
    - 예를 들어, 다음과 같은 클래스가 있다고 할 때
        ![image](https://user-images.githubusercontent.com/7943694/75551549-cfac3900-5a77-11ea-88a2-5a259fc5e7a0.png)

        ```java
        Dog d = new Dog();
        d.bark();
        ```
        보다는
        
        ```java
        Animal animal = new Dog();
        animal.makeSound();
        ```
        또 이것 보다는
        
        ```java
        a = getAnimal();
        a.makeSound();
        ```
        로 구현하는게 좋다. 왜냐면 두번째 형식도 코드에 특정 클래스 타입이 등장하기 때문이다

        스트레티지 패턴의 키 포인트는 behavior 를 *delegate* 한다는 것이다
        기존에 오리 subclass에 있던 fly 함수대신 performFly 함수를 선언하고 내부에서 behavior class 에 정의된 fly 함수를 호출한다
        그럼 오리 subclass는 behavior 의 디테일을 신경쓰지않아도 된다

        - **여기서 우리는 IS-A 관계인 inheritance 대신 HAS-A 관계인 composition 을 사용한 것인데, 여기서 또다른 Design Principle 이 등장한다.**
        - **Favor composition over inheritance**
        - inheritance  subclass 가 superclass  강하게 결합되며, 컴파일 타임에 subclass 의 성격이 정해져버리는 단점이 있어서 좋지 않을 때도 있다
        - composition 을 사용하면 runtime 에 behavior 를 변경할 수가 있어져, 더 유연한 설계를 가능하게 한다
        - composition 은 여러 디자인패턴에서 사용된다

- 추가 설명
    - OO basics 를 잘 따른다고, 항상 extensible & flexible & reusable & maintainable 한 설계를 보장해주진 않는다. OO 의 속성들이 항상 명확하진 않기때문에 OO basics 를 따른 설계들 중에서도 오랫동안 검증된 방식의 모음이 디자인 패턴인것 
    - 개발 도중과 완료 이후 중에 더 시간을 많이 들어가는 것은 개발 완료 이후이기 때문에, reuse 보단 extensibility 와 maintainability 를 더 신경써야한다
    - reuse 를 달성하는 방법은 상속 이외에도 다양한 방법들이 있기때문에 꼭 상속을 사용할 필요는 없다

- Strategy Pattern 에 적용되는 Design Principles
    1. 변경되는 부분을 변경되지 않는 부분과 분리해라(Identify the aspects of your application that vary and seperate them from what stays the same)
    2. 구현체가 아니라 인터페이스를 사용하여 프로그래밍해라(Program to an interface, not an implementation)
    3. 상속보다 구성을 선호해라(Favor composition over inheritance)

## Observer 패턴

![image](https://user-images.githubusercontent.com/7943694/75998442-37fd8d80-5f44-11ea-8d4f-9ebac933f5d5.png)  

```
객체들간의 일대다 의존관계를 만들어 하나의 객체가 변하면 이 객체에 의존하는 객체들이 모두 알림을 받고 자동으로 업데이트 되는 디자인 패턴
```

- 날씨 앱 만들기
    -  초기버전
        ```java
        class WeatherData {
            public void measurementsChanged() {
                float temp = getTemperature();
                float humidity = getHumidity();
                float pressure = getPressure();
        
                currentConditionsDisplay.update(temp, humidity, pressure);
                statisticsDisplay.update(temp, humidity, pressure);
                forecastDisplay.update(temp, humidity, pressure);
            }
        }
        ```
    - 문제점
        - display 가 추가될 때마다 코드를 변경해야함
        - display 를 런타임에 추가/삭제할 수 없다
        - 인터페이스가 아닌 구체적인 구현으로 코딩하고있다
        - 변화하는부분을 캡슐화하지 못했다

    - 옵저버 패턴 적용
        * Subject 라는 데이터를 관리하는 단 하나의 대상을 두고 변경시에만 동기화를 하여 Observer 들이 공유하도록 함
        * 굳이 모든 대상이 데이터를 관리하지 않아도 됨
        * notify 순서에 의존하지마라
        * 장점
            * 어떤 클래스이던간에 상관없이 Observer 인터페이스를 구현하기만하면  데이터 변경시 알림을 받을 수 있다
            * Subject 는 각 Observer 들이 실제로 어떤 클래스인지 알 필요 없이 일관된 인터페이스로 데이터 변경 알림을 줄 수 있다
            * 새로운 Observer 를 추가해야 하는 경우에도 Subject 는 코드의 변경 없이 이를 구행할 수 있음

- Design Principal
    * Strive for loosely coupled designs between objects that interact
    * 느슨하게 결합된 설계는 더 유연한 코드를 만든다

- 일반적인 observer pattern
    * Subject 와 Observer 로 이루어짐
    * push 방식(subject 만 observer 에게 데이터를 보내줄 수 있음)

- Java built-in observer pattern
    * 특징
      * Observable 과 Observer 로 이루어짐
      * 일반적인 옵저버 패턴의 Subject interface 와는 다르게 Observable 이 클래스임
    * 장점
      * push 방식과 pull 방식(옵저버가 직접 subject/observable 의 데이터를 가져가는 방식) 모두 지원
      * setChanged() 와 changed 필드를 통해 유연함을 추가했다(잦은 데이터가 변경으로 notify 를 너무 자주하는경우, 특정 수준 이상으로 크게 변경되었을 경우만 setChanged() 를 호출하여 notify 하도록 가능. pretected 로 선언되어있어서 observer 가 호출하는게아니라 subject 자신이 호출하는것임)
      * 주요 메소드를 상속받기 때문에 직접 구현할 필요없다
    * 단점
      * setChanged 가 protected 여서 서브클래스 내부가 아니라면 Composition 방식으로는 호출할수가 없다
      * class 를 상속받는방식이어서 우리 나름대로 로직을 구현할수없다

- java.util Observer 는 Deprecated 
    * 자바9 부터 java.util.Observable/Observer 가 deprecated 되었다
    * https://stackoverflow.com/questions/46380073/observer-is-deprecated-in-java-9-what-should-we-use-instead-of-it

    - 이유
        * Observable 이 serializable 을 구현하짇 않앗고, 모든 멤버가 private 이라 serialize 하지 못한다
        * Thread safety 하지 않음
        * 뭐가 변했는지 안알려줌 단순히 변했다는것만 알수있음
        * 모든 Observable 이 똑같다. instanceof 로 검사하여 어떤 타입으로 타입캐스트하는 로직을 구현해야한다
        * 그밖에 버그 및 레거시 코드 관리의 어려움 등

    - 대안
        * java.beans 에 있는 PropertyChangeSupport 와 PropertyChangedListener (그리고 PropertyChangedEvent)
        * Listeners 는 많은 타입이 있고 callback method 도있고 casting 할 필요도없다
        * PropertyChangeListener 추천
        * Listener 도 역시 Observer Pattern 이다!

- pull 방식 vs push 방식
    - push 방식
        * 장점
            * 데이터 변경시에만 알림을 받을 수 있어서 효율적임
        * 단점
            * 모든 옵저버에게 일관된 방식으로 데이터를 줘야하기 때문에 옵저버 입장에서는 필요하지 않은 데이터일지라도 모두 받아야함
            * subject 가 관리하는 새로운 데이터가 추가될 경우 observer 들에게 변경된 데이터를 notify 하는 부분의 코드의 변경이 불가피함
    - pull 방식
        * 장점
            * 각 옵저버들은 필요한 데이터만 getter 메소드를 통해 받아올 수 있음
            * subject 가 관리해야하는 새로운 데이터가 추가되어도 notify 해주는 부분의 코드 변경없이 getter 만 만들어 주면됨
        * 단점
            * 데이터가 변경되지 않았을 때도 매번 getter 를 통해 데이터를 직접 가져가야함

        **push 보단 pull 이 더 적절한 방식으로 여겨진다**  
- 실생활 예
    - Java swing 의 JFrame 에서 JButton 과 ActionListener 

## Decorator 패턴
## Factory Method 패턴 & Abstract Factory 패턴
## Singleton 패턴
## Command 패턴
## Adapter 패턴 & Facade 패턴
## Template Method 패턴
## Iterator 패턴 & Composite 패턴
## State 패턴
## Proxy 패턴
## Compound 패턴

# 덜 쓰이지만 유명한 패턴 9가지
## Bridge 패턴
## Builder 패턴
## Chain of Responsibility 패턴
## Flyweight 패턴
## Interpreter 패턴
## Mediator 패턴
## Memento 패턴
## Prototype 패턴
## Visitor 패턴

# 이 책의 좋은점
어떤 설계가 좋고, 왜 좋은지 설명해준다.
또한 비슷한 디자인 패턴들을 비교하며 공통점과 차이점에 대해 명확히하며 자칫하면 헷갈릴 수도 있고, 의문이 드는 점들을 잘 해결해준다.