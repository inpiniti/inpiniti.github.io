---
title: 오브젝트
author: JUNG YoungKyun
date: 2022-07-25
category: 18 book
layout: post
---

![오브젝트](../images/18 book/05 오브젝트/오브젝트 표지.jpg)

|도서명|[오브젝트 코드로 이해하는 객체지향 설계](https://wikibook.co.kr/object/)|
|---|---|
|지은이|조영호 지음|
|출판사|위키북스|
|ISBN|9791158391409|
|금액|38,000원|
|출판일|2019년 06월 17일 발행(개정판)|
|페이지수|656쪽|
|참고|Blog-Shine[오브젝트](https://blogshine.tistory.com/200)|

# 들어가며 프로그래밍 패러다임

- 프로그래밍 언어는 일반적으로 어떤 패러다임의 사용을 권장하고 다른 패러다임의 사용을 막는다.
- 기본 개념에 대한 노골적인 의견 충돌이 빚어지는 일이 드물어 지고,
- 동일한 규칙과 표준에 헌신하게 된다.

# 01 객체, 설계

## 1. 티켓 판매 어플리케이션 구현하기
    
책에서 나온 티켓 판매 어플리케이션은 절차지향적이다. 이를 개선해 나가야 한다.

구현한 클래스 다이어그램은 다음과 같다.

![그림1.2 너무 많은 클래스에 의존하는 Theater](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F9a2vZ%2FbtrscNFNKJx%2Fy1HdVKGHvKYW9clXDoBEnK%2Fimg.png)
*그림1.2 너무 많은 클래스에 의존하는 Theater*

우선 절차 지향방식의 Theater는 다음과 같다.

```java
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience){
        if(audience.getBag().hasInvitation()){
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        }else{
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```
한눈에 봐도 매우 절차지향적이다.

로버트 마틴은 소프트웨어 모듈이 가져야 하는 3가지 기능에 관해 다음과 같이 설명한다.
1. 모듈은 정상적으로 실행되어야 한다
2. 변경에 용이해야 한다
3. 이해하기 쉬워야 한다.

위 코드는 필요한 기능을 오류없이 정확하게 수행하고 있다. 제대로 동작해야 한다는 제약을 만족한다.
**하지만,** 변경 용이성과 이해하기 쉬워야 한다는 제약은 만족시키지 못하고 있다.

위 코드는 여러가지 문제가 있다.
1. 소극장이 관람객의 가방에서 직접 돈을 가져간다. 관람객의 허락과는 상관없이 소극장이 관람객의 가방에 접근하고 있다.
2. 소극장이 직접 매표소의 티켓과 현금에 접근한후, 관람객에게 티켓을 전달하고, 받은 돈을 관람객의 매표소에 적립한다.

=> 티켓판매원이 하는 일이 없다.

따라서 위 코드는 우리의 상식과는 너무 다르게 작동하고 있다.
또한 코드를 이해하기 위해 세부적인 내용을 한꺼번에 기억하고 있어야 한다.

> **가장 큰 문제는 Audience 와 TicketSeller를 변경할 경우 Theater를 함께 변경해야한다는 사실이다.**

예를 들어 관람객이 가방을 들고있다는 가정이 변경된다고 해보자.
**Theater는** 관람객이 가방을 들고 있고 판매원이 매표소에서만 티켓을 판매한다는 **지나치게 세부적인 사실에 의존**해서 동작한다.

이처럼 다른 Class 가 Audience의 내부에 대하여 더 많이 알면 알수록 Audience의 변경이 어려워 진다.

이것이 객체 사이의 의존성(dependency)와 관련된 문제이다.
의존성이라는 말 내부에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

그렇다고 모든 의존성을 제거하자는 것이 아니다!, 최소한의 의존성만 유지하고, 불필요한 의존성을 제거해야 한다.
맨 위 다이어그램에서 살펴봤듯 Theater는 너무 많은 클래스에 의존하고 있다.
이렇게 객체 사이의 의존성이 과한 경우를 결합도(coupling)가 높다고 말한다.
    
## 2. 설계 개선하기

우리는 변경과 의사소통이라는 문제가 서로 엮여 있음에 주목해야 한다.

코드를 이해하기 어려운 이유는 Theater가 관람객의 가방과 판매원의 매표소에 직접적으로 접근하기 때문이다.
이는 Theater가 Audience 와 TicketSeller에 결합된다는 것을 의미한다.

이를 해결하기 위해, 정보를 차단해야 한다.
과연 Theater가 관람객이 가방을 갖고 있다는 사실과, 판매원이 매표소에서 티켓을 판매한다는 사실을 알아야 할까??

> **알 필요가 없다!**

관람객이 스스로 요금을 계산하고, 판매원이 스스로 티켓을 판매한다면 모든 문제가 해결된다.
**관람객과 판매원을 자율적인 존재로** 만들어야 하는것 이다.

1. Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기는 것 이다.

    Theater 내부에 있던 enter 코드의 logic을 TicketSeller에게로 옮겨보자!
    
    ```java
    public class TicketSeller {
        private TicketOffice ticketOffice;
    
        public TicketSeller(TicketOffice ticketOffice) {
            this.ticketOffice = ticketOffice;
        }
    
        public void sellTo(Audience audience){
            if(audience.getBag().hasInvitation()){
                Ticket ticket = ticketOffice.getTicket();
                audience.getBag().setTicket(ticket);
            }else{
                Ticket ticket = ticketOffice.getTicket();
                audience.getBag().minusAmount(ticket.getFee());
                ticketOffice.plusAmount(ticket.getFee());
                audience.getBag().setTicket(ticket);
            }
        }
    }
    ```

    이제 ticketOffice에 대한 접근은 오직 TicketSeller에서만 가능하다.
    TicketSeller는 ticketOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로  수행할수밖에 없다.
    => 이를 캡슐화 라고 부른다. **캡슐화를 통해 변경하기 쉬운 객체를 만들게 된다.**
    
    Theater의 enter 메서드는 다음과 같이 간단하게 변경된다.
    
    ```java
    public class Theater {
        private TicketSeller ticketSeller;
    
        public Theater(TicketSeller ticketSeller) {
            this.ticketSeller = ticketSeller;
        }
    
        public void enter(Audience audience){
            ticketSeller.sellTo(audience);
        }
    }
    ```

    이제 Theater는 ticketOffice에 대하여 전혀 알지 못한다.
    Theater는 단지 ticketSeller의 sellTo 메서드를 통해 메시지를 이해하고 응답할수 있을 뿐이다.
    
    Theater는 오직 TicketSeller의 인터페이스에 의존한다.
    TicketSeller가 내부에 TickerOffice 인스턴스를 포함하고 있다는 사실을 구현의 역영게 해당된다.

2. Audience 를 캡슐화 하자. TicketSeller는 Audience는 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근한다.
    
    캡슐화 하는 방식은 이전과 같다.
    
    Audience에서 buy() 라는 메서드를 만들어 줬다.

    ```java
    public class Audience {
        private Bag bag;
    
        public Audience(Bag bag) {
            this.bag = bag;
        }
    
        public Long buy(Ticket ticket){
            if(bag.hasInvitation()){
                bag.setTicket(ticket);
                return 0L;
            }else{
                bag.setTicket(ticket);
                bag.minusAmount(ticket.getFee());
                return ticket.getFee();
            }
        }
    }
    ```

    변경 된 코드에서는 Audience가 자신의 가방안에 초대장이 들어있는지 스스로 확인한다.
    Audience가 가방을 직접 다루기 때문에 외부에 더이상 getter를 노출시킬 필요가 없다.
    getBag()을 제거하고 결과적으로 Bag의 존재를 내부로 캡슐화할 수 있게되었다.
    
    Audience 와 TicketSeller를 자율적인 객체로 만들었다!

    ![그림 1.6 자율적인 Audience와 TicketSeller로 구성된 설계](../images/18 book/05 오브젝트/object-1-6.png)
    *그림 1.6 자율적인 Audience와 TicketSeller로 구성된 설계*
        
### 캡슐화와 응집도

    핵심은 객체 내부의 상태를 캡슐화 하고, 객체 간에 오직 메시지를 통해서만 상호작용 하도록 만드는 것 이다.
    
    Theater는 
    단지 TicketSeller 가 sellTo 메서드를 통해 응답할수 있다는 사실만 알고 있을 뿐 이다.
    단지 Audience 가 buy 메시지에 응답할 수 있고 자신이 원하는 결과를 반환할 것 이라는 사실만 알고있다.
    
    객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임지고, 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력해야 한다.
    
### 절차지향 vs 객체지향

    - 절차지향
    
        절차지향 적 관점에서는 Theater의 enter 메서드는 Process 이며, audience, ticketSeller, bag, ticketOffice 는 데이터 이다.
        이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차지향적 프로그래밍 이라 부른다.
    
    - 객체지향
    
        데이터를 스스로 처리하도로고 하여 프로세스가 데이터를 소유하고 있는 Audience, TicketSeller 내부로 옮기는 방식을
        객체지향 프로그래밍 이라 부른다.
        
        즉, 객체지향은 책임을 분산시킨다. 이전의 절차지향 모델은 Theater에 책임이 몰려있다.
        하지만 객체지향은 책임을 적절하게 객체들에게 분산시키게 된다.
        
        ![그림 1.8 책임이 분산된 객체지향 프로그래밍](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcv8N3e%2Fbtrr3n3dj5G%2FkBhMmDUL5POjUbI8JcFAyK%2Fimg.png)
        *그림 1.8 책임이 분산된 객체지향 프로그래밍*

### 그래 거짓말이다!

    이전까지 객체는 스스로의 처리를 위해 Audience와 TicketSeller 역시 스스로 자신을 책임져야 한다 했었다.
    하지만 Theater는? Bag? TicketOffice는? 이들은 실세계 에서는 자율적인 존재가 아니다.
    가방에서 돈을 꺼내는것은 관람객이지 가방이 아니다.
    
    하지만 이들을 생물처럼 스스로 행동하고, 자신을 책임지는 자율적인 존재로 취급했다.
    
    이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 **의인화(anthropomorphism)**이라 부른다.
    실세계 에서는 생명이 없는 수동적인 존재라고 하더라고, 객체지향 세계로 넘어오는 순간 그들은 생명과 지능을 가진
    싱싱한 존재로 다시 태어난다.

# 02 객체지향 프로그래밍

1. 객체지향 프로그래밍을 향해

    진정한 객체지향 페러다임으로의 전환은 Class 가 아닌, Object에 초점을 맞출 때 에만 얻을 수 있다.
    
    1. 어떤 클래스가 필요한지가 아니라, 어떤 객체가 필요한지 고민해야 한다.
    
        클래스는 공통적인 객체들의 상태와 행동을 추상화 한 것 이다. 따라서 Class를 추상화 시키려면 어떤 객체가 필요한지 알아야 한다.
    
    2. 객체는 독립적인 존재가 아니다, 기능 구현을 위해 협력하는 공동체의 일원으로 봐야한다.
    
        객체를 고립된 존재로 바라보지 말고, 협력에 참여하는 협력자로 바라봐야 한다.
        다른 객체에게 도움을 주거나, 의존하면서 살아가는 협력적인 존재이다.
        객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 Class를 구현해라.
        
    - 도메인의 구조를 따르는 프로그램 구조
        
        도메인(domain)이란 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라 부른다.
        
        객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터, 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할수 있기 때문이다.
        요구사항과 프로그램을 객체라는 동일한 관점에서 보기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결된다.
        
        다음 도메인을 살펴보자.
        
        ![그림 2.3 영화 예매 도메인을 구성하는 타입들의 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdracQ9%2FbtrsfXP2CBS%2FW31wQCqrtCQkvWSJhKAq7k%2Fimg.png)
        *그림 2.3 영화 예매 도메인을 구성하는 타입들의 구조*
        
        일반적으로 클래스 기반의 객체지향 언어에서는 도메인 개념을 구현하기 위해 Class를 사용한다.
        Class의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
        Class 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어야 프로그램의 구조를 이해하고, 예상하기 쉬워진다.
        
        따라서 Class 다이어그램을 도메인 모델과 유사한 형태를 보이게 된다. 다음과 같이 말이다.
        
        ![그림 2.4 도메인 개념의 구조를 따르는 클래스 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSx7TJ%2Fbtrr7pG7a45%2FggO8g6Fhb5GOpqxmUk5bi0%2Fimg.png)
        
    - 자율적인 객체
    
        객체에게는 중요한 2가지 사실이 있다.
        
        1) 객체는 상태(state) 와 행동(behavior)을 함께 가지는 복합적인 존재라는 것 이다.
        2) 객체는 스스로 판단하고, 행동하는 자율적인 존재이다.
        
        객체지향 페러다임 에서는 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 **캡슐화** 시킬수 있다.
        
        또한 대부분의 객체지향 언어에서는 public, private 과 **같은 접근 수정자**를 제공한다.
        이와 같이 접근 수정자를 통해 객체 내부에 대한 접근을 제어하는 이유는 객체를 자율적인 존재로 만들기 위해서이다.
        
        객체 스스로가 상태를 관리하고, 행동하는 지율적인 객체가 되려면 외부의 간섭을 최소화 해야한다.
        외부에서 객체의 결정에 직접적으로 개입하려 하면 안된다. 객체에게 요청만 하고, 스스로 최선의 방법을 경정하도록 해야한다.
        
        캡슐화와 접근제어는 객체를 두 부분으로 나눈다.
        
        1) 외부에서 접근 가능한 부분으로 이를 public interface 라고 부른다.
        2) 외부에서는 접근 불가능하고, 오직 내부에서만 접근 가능한 부분으로 이를 implementation 이라 부른다. 
        
        일반적으로 Java로 생각해보면 클래스의 속성은 private로 감추고, 외부에 제공해야 하는 일부 메서드만 public으로 선언한다.
        public interface에는 public으로 지정된 메서드만 포함한다.
        그 밖의 private 메서드나 protected 메서드, 속성은 implementation 에 해당된다.
        
    - 프로그래머의 자유
        - 클래스 작성자(class creator) : 새로운 데이터 타입을 프로그램에 추가
        - 클라이언트 프로그래머(client programmer) : 클래스 작성자가 추가한 데이터 타입을 사용한다.
        
        class creator는 client programmer 에게 필요한 부분만 공개하고, 나머지는 숨겨야 한다.
        class creator입장에서는 client programmer가 숨겨놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래밍에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. => 이를 **구현은닉(implementation hiding)**이라고 부른다.
        
        이를 통해 client programmer는 내부 구현은 무시한채 인터페이스만 알고 있어도 class를 사용할 수 있기 때문이다.
        따라서 client programmer가 알아야 할 지식의 양이 줄어든다.

    - 협력에 관한 짧은 이야기
    
        객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)할 수 있다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.
        
        객체가 다른 객체와 상호작용 하는 유일한 방법은 메시지를 전송(send a message)하는 것 뿐이다.
        메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
        이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.
        
        예를 들어 다음 코드의 일부를 살펴보자.
        
        ```java
        public class Screening {
        
            private Money calculateFee(int audienceCount) {
                return movie.calculateMovieFee(this).times(audienceCount);
            }
        }
        ```
    
        위 코드는 'Screening이 Movie 에게 calculateMovieFee 메시지를 전송한다' 라고 말하는것이 적절하다.
        사실 Screening은 Movie안에 calculateMovieFee 메서드가 존재하고 있는지 조차 모른다.
        단지 Movie 가 calculateMovieFee 메시지에 응답할 수 있다고 믿고 메시지를 전송할 뿐이다.
        
        메시지를 받은 Movie는 스스로 적절한 메서드를 선택한다.
        
2. 할인 요금 구하기
    
    
# 03 역할, 책임, 협력

# 04 설계 품질과 트레이드오프

# 05 책임 할당하기

# 06 메시지와 인터페이스

# 07 객체 분해

# 08 의존성 관리하기

# 09 유연할 설계

# 10 상속과 코드 재사용

# 11 합성과 유연한 설계

# 12 다형성

# 13 서브클래싱과 서브타이밍

# 14 일관성 있는 협력

# 15 디자인 패턴과 프레임워크

# 마치며 나아가기

# 부록 A 계약에 의한 설계

# 부록 B 타입 계층의 구현

# 부록 C 동적인 협력, 정적인 코드 

