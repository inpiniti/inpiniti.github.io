---
title: 01 파이썬 기반의 머신러닝과 생태계 이해
author: JUNG YoungKyun
date: 2022-06-11
category: 15 ai
layout: post
---

![write date](https://img.shields.io/badge/write_date-2022_05_12-blue.svg)

# 01 머신러닝의 개념

일반적으로 애플리케이션을 수정하지 않고도 데이터를 기반으로 패턴을 학습하고 결과를 예측하는 알고리즘 기법을 통칭

현실 세계의 매우 복잡한 조건으로 인해 기존의 소프트웨어 코드만으로는 해결하기 어려웠던 많은 문제점들을 머신러닝을 이용하여 해결해 나가고 있음

소프트웨어 코드로 로직을 구성하여 이들을 관통하는 일정한 패턴을 찾기 어려운 경우에 머신러닝은 훌륭한 솔루션을 제공함

데이터를 기반으로 통계적인 신뢰도를 강화하고 예측 오류를 최소화하기 위한 다양한 수학적 기법을 적용해 데이터 내의 패턴을 스스로 인지하고 신뢰도 있는 
예측 결과를 도출함

데이터마이닝, 영상 인식, 음성 인식, 자연어 처리에서 개발자가 데이터나 업무 로직의 특성을 직접 감안한 프로그램을 만들 경우 난이도와 개발 복잡도가
너무 높아질 수밖에 없는 분야에서 머신러닝은 급속하게 발전을 이루고 있음

## 머신러닝의 분류

지도 학습
- 분류
- 회귀
- 추천시스템
- 시각/음성감지/인지
- 텍스트 분석, NLP

비지도 학습
- 클러스터링
- 차원 축소
- 강화학습

책 추천 : <<마스터 알고리즘>>

머신러닝 알고리즘을 기호주의, 열결주의, 베이지안 통계, 유추주의 등의 유형으로 나누어 설명

## 데이터 전쟁

데이터와 머신러닝 알고리즘 모두 중요한 요소임

머신러닝 세상이 본격적으로 펼쳐진다면 데이터의 중요성이 무엇보다 커짐

머신러닝의 가장 큰 단점은 데이터에 매우 의존적임

좋은 품질의 데이터를 갖추지 못한다면 머신러닝의 수행 결과는 좋을 수 없음

최적의 머신러닝 알고리즘과 모델 파라미터를 구축하는 능력도 중요하지만,
데이터를 이해하고 효율적으로 가공, 처리, 추출해 최적의 데이터를 기반으로
알고리즘을 구동할 수 있도록 준비하는 능력이 더 중요함.

## 파이썬과 R 기반의 머신러닝 비교

머신러닝 프로그램을 작성할 수 있는 대표적인 오픈 소스 프로그램 언어는 파이썬과 R 입니다.

R은 통계 전용 프로그램 언어로, SPSS, SAS, MATLAB 등 전통적인 통계 및 마이닝 패키지를 개선하고자 만든 언어

파이썬은 개발 전문 프로그램 언어로, 객체지향과 함수형 프로그래밍 모두를 포괄하는 유연한 프로그램 아키텍처, 다양한 라이브러리 등의 큰 강점을 가짐

개발 언어에 익숙하지 않으나 통계 분석에 능한 현업 사용자라면 R을 선택하는 것이 더 나을 수도 있으나, 머신러닝을 처음 시작하는 사람이라면, 특히
개발자라면 파이썬을 권함

파이썬 R에 비해 뛰어난 점은
- 쉽고 뛰어난 개발 생산성으로 전 세계 개발자들이 파이썬을 선호함. 특히 구글, 페이스북 등 유수의 IT 업계에서도 파이썬의 높은 생산성으로 인해 활용도가 높음
- 오픈 소스 계열의 전폭적인 지원을 받고 있고, 놀라울 정도의 많은 라이브러리로 인해 개발 시 높은 생산성을 보장함
- 인터프리터 언어의 특성상 속도는 느리지만, 대신에 뛰어난 확장성, 유연성, 호환성으로 인해 서버, 네트워크, 시스템, IOT, 심지어 데스크톱까지 다양한
영역에서 사용됨
- 머신러닝 애플리케이션과 결합한 다양한 애플리케이션 개발 가능
- 엔터프라이즈 아키텍처로의 확장 및 마이크로서비스 기반의 실시간 연계 등 다양한 기업 환경으로의 확산이 가능

무엇보다 유수의 딥러닝 프레임워크인 텐서플로, 케라스, 파이토치 등에서 파이썬 우선 정책으로 파이썬을 지원하고 있음

# 02 파이썬 머신러닝 생태계를 구성하는 주요 패키지

- 머신러닝 패키지 : 대표적 머신러닝 패키지는 사이킷런으로, 데이터 마이닝 기반의 머신러닝에서 독보적인 위치를 차지함
- 행렬/선형대수/통계 패키지 : 대표적인 행렬과 선형대수를 다루는 패키지는 넘파이(NumPy) 이며, 더불어 사이파이(SciPy)는 자연과학 통계를 위한 패키지 지원
- 데이터 핸들링 : 판다스는 대표적인 데이터 처리 패키지임
- 시각화 : 대표적인 시각화 패키지 맷플롯립
- 이 외 여러 서드파티 라이브러리
- 주피터

## 파이썬 머신러닝을 위한 S/W 설치

Anaconda 설치

pip 로 패키지들을 설치도 가능하지만 불편하기 떄문에, 필요한 패키지들을 일괄적으로 설치할 수 있는 Anaconda를 이용함

1. https://www.anaconda.com/download/ 접속

2. Anaconda 설치 파일을 내려받음
3. 파이썬, 넘파이, 판다스, 맷플롯립, 시본, 주피터 노트북이 설치됨
4. Anaconda Prompt 는 Anaconda를 이용하여 패키지 설치할 때 사용
5. Anaconda Prompt 관리자 권한으로 실행
```javascript
// 버전 확인
python -V

Python 3.7.1
```
6. Jupyter Notebook 실행 -> 서버 프로그램이 실행 됨
7. 브라우저에서 http://localhost:8888 접속
8. New 로 새로운 주피터 노트북 생성
```javascript
import numby
import pandas
import matplotlib.pyplot
import seaborn
form sklearn.model_selection import train_test_spllit
```
9. 위 import 코드를 입력해도 오류가 발생하지 않으면 정상 설치가 완료 된 것임
10. Microsoft Visual Studio Build Tool 2015 이상 버전 설치 (4장 분류, 9장 추천 시스템에서 사용하는 패키지를 설치하기 위해)

# 03 넘파이

많은 머신러닝 알고리즘이 넘파이 기반으로 작성돼 있기 때문에, 이해하는 것이 매우 중요함.

단 직접 패키지 등을 만드는 개발자가 아니라면 상세하게 알 필요는 없음

## 넘파이 ndarray 개요

```javascript
import numpy as np
```

ndarray를 이용해 다차원 배열을 쉽게 생성하고 다양한 연산 수행 가능

### array() : 다양한 인자를 입력받아 ndarray로 변환하는 기능 수행
생성된 ndarray 배열의 shape 변수는 ndarray의 크기(행 열을 튜플 형태로 가짐)를 가지고 ndarray배열의 차원까지 알수 있음

```javascript
array1 = np.array([1,2,3])
print('array1 type:', type(array1))
print(`array1 array 형태:`, array1.shape)

array2 = np.aaray([[1,2,3],
                    [2,3,4]])
print('array2 type:', type(array2))
print('array2 array 형태:', array2.shape)

array3 = np.array([[1,2,3]])
print('array3 type:', type(array3))
print(`array3 array 형태:`, array3.shape)
```

`Output`
```javascript
array1 type: <class 'numpy.ndarray'>
array1 array 형태: (3, )
array2 type: <class 'numpy.ndarray'>
array2 array 형태: (2, 3)
array3 type: <class 'numpy.ndarray'>
array3 array 형태: (1, 3)
```

### ndarray.ndim : array의 차원 확인

```javascript
print('array1: {:0}차원, array2: {:1}차원, array3: {:2}차원'.format(array1.ndim,
                                                                array2.ndim, array3.ndim))
```

`Output`
```javascript
array1: 1차원, array2: 2차원, array3: 2차원
```

## ndarray의 데이터 타입

ndarray 내의 데이터 값
- 숫자 값
- 문자열 값
- 불 값

숫자형
- int형 (8bit, 16bit, 32bit)
- unsigned int형 (8bit, 16bit, 32bit)
- float형 (16bit, 32bit, 64bit, 128bit)
- complex타입 (더 큰 숫자 및 정밀도)

```javascript
list1 = [1, 2, 3]
print(type(list1))
array1 = np.array(list1)
print(type(array1))
print(array1, array1.dtype)
```

`Output`
```javascript
<class 'list'>
<class 'numpy.ndarray'>
[1 2 3] int32
```

```javascript
list2 = [1, 2, 'test']
array2 = np.array(list2)
print(array2, array2.dtype)

list3 = [1, 2, 3.0]
array3 = np.array(list3)
print(array3, array3.dtype)
```

`Output`
```javascript
// U11 은 유니코드 문자열임
<class 'numpy.ndarray'>
['1' '2' 'test'] <U11
[1. 2. 3.] float64
```

### astype() : ndarray 내 데이터 값의 타입 변경이 가능함

```javascript
array_int = np.array([1, 2, 3])
array_float = array_int.astype('float64')
print(array_float, array_float.dtype)

array_int1 = array_float.astype('int32')
print(array_int1, array_int1.dtype)

array_float1 = np.array([1.1, 2.1, 3.1])
array_int2 = array_int.astype('int32')
print(array_int2, array_int2.dtype)
```

`Output`
```javascript
[1. 2. 3.] float64
[1 2 3] int32
[1 2 3] int32
```

## ndarray를 편리하게 생성하기 - arange, zeros, ones

arange(), zeros(), ones() : 쉽게 ndarray 를 생성할 수 있음

테스트용으로 데이터 만들거나 대규모 데이터를 일괄적으로 초기화 하는 경우 사용

### arange() : 0부터 인자값 까지 순차적으로 데이터값으로 변환

```javascript
sequence_array = np.arange(10)
print(sequence_array)
print(sequence_array.dtype, sequence_array.shape)
```

`Output`
```javascript
[0 1 2 3 4 5 6 7 8 9]
int32 (10, )
```

### zeros() : 모든 값을 0으로 채운 해당 shape를 가진 ndarray를 반환

### ones() : 모든 값을 1로 채운 해당 shape를 가진 ndarray를 반환

```javascript
zero_array = np.zeros((3, 2), dtype='int32')
print(zero_array)
print(zero_array.dtype, zero_array.shape)

one_array = no.ones((3, 2))
print(one_array)
print(one_array.dtype, one_array.shape)
```

`Output`
```javascript
[[0 0]
[0 0]
[0 0]]
int32 (3, 2)
[[1. 1.]
[1. 1.]
[1. 1.]]
float64 (3, 2)
```

## ndarray의 차원과 크기를 변경하는 reshape()

ndarray를 특정 차원 및 크기로 변환

```javascript
array1 = np.arange(10)
print('array1:\n', array1)

array2 = array1.reshape(2, 5)
print('array2:\n', array2)

array3 = array1.reshape(5, 2)
print('array3:\n', array3)
```

`Output`
```javascript
array1:
[0 1 2 3 4 5 6 7 8 9]
array2:
[[0 1 2 3 4]
[5 6 7 8 9]]
array3:
[[0 1]
[2 3]
[4 5]
[6 7]
[8 9]]
```

지정된 사이즈로 변경이 불가능하면 오류 발생

```javascript
array4 = array1.reshape(4, 3)

ValueError
```

실전에서 효율적으로 사용하는 경우는 -1을 적용하는 경우

```javascript
array1 = np.arange(10)
print(array1)

array2 = array1.reshape(-1, 5)
print('array2 shape:', array2.shape)

array3 = array1.reshape(5, -1)
print('array3 shape', array3.shape)
```

`Output`
```javascript
[0 1 2 3 4 5 6 7 8 9]
array2 shape: (2, 5)
array3 shape: (5, 2)
```

물론 -1을 사용하더라도 호환 될 수 없는 형태는 변환할 수 없음

```javascript
array4 = array1.reshape(4, 3)

ValueError
```

reshape(-1, 1) 이런 형태로 자주 사용되며,
tolist() 는 리스트 자료형으로 변환 가능함 (시각적으로 더 이해하기 쉬울거 같아 리스트로 변환하여 출력함)

```javascript
array1 = np.arange(8)
array3d = array1.reshape((2, 2, 2))
print('array3d:\n', array3d.tolist())

# 3차원 ndarray를 2차원 ndarray로 변환
array5 = array3d.reshape(-1, 1)
print('array5:\n', array5.tolist())
print('array5 shape', array5.shape)

# 1차원 ndarray를 2차원 ndarray로 변환
array6 = array1.reshape(-1, 1)
print('array6:\n', array6.tolist())
print('array6 shape', array6.shape)
```

`Output`
```javascript
array3d:
[[[0, 1], [2, 3]], [[4, 5], [6, 7]]]
array5: [[0], [1], [2], [3], [4], [5], [6], [7]]
array5 shape: (8, 1)
array6: [[0], [1], [2], [3], [4], [5], [6], [7]]
array6 shape: (8, 1)
```

## 넘파이의 ndarray의 데이터 세트 선택하기 - 인덱싱(indexing)

1. 특정한 데이터

## 행렬의 정렬 - sort()와 argsort()

## 선형대수 연산 - 행열 내적과 전치 행렬 구하기

# 04 데이터 핸들링 - 판다스

## 판다스 시작 - 파일을 DataFrame으로 로딩, 기본 API

## DataFrame과 리스트, 딕셔너리, 넘파이 ndarray 상호 변환

## DataFrame의 칼럼 데이터 세트 생성과 수정

## DataFrame 데이터 삭제

## Index 객체

## 데이터 셀렉션 및 필터링

## 정렬, Aggregation 함수, GroupBy 적용

## 결손 데이터 처리하기

## apply lambda 식으로 데이터 가공

# 05 정리