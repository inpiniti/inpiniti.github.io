---
title: 11 리덕스
author: JUNG YoungKyun
date: 2022-07-22
category: 04 react
layout: post
---

# 1 리덕스
리덕스는 리액트 생태계에서 가장 사용률이 높은 상태관리 라이브러리입니다.

## 1.1 리덕스가 나오게 된 배경?
1. 글로벌 **상태관리하기가 매우 까다로웠기에 사용**되었었으나 최근에는 Context API 를 활용하는 것 만으로도 충분하다고 합니다.

2. 아래 그림 참조

    보통 컴포넌트들은 직접 소통하지 않고, 부모를 통한 소통을 합니다.
     
    ![나오게 된 배경](../images\04\11\01 나오게 된 배경.png)

    위 와 같이 부모에서 데이터를 관리하는 것이 편하긴 하나, 대규모 프로젝트에서는 힘들어집니다.

    ![데이터 전달](../images\04\11\02 데이터 전달.png)
    
    위 그림은 **Root에서 G까지의 데이터 전달하는 것이 쉽지 않음**을 나타내고 있습니다.
    
3. 리덕스 와 Context API 와의 차이

    1. 리덕스에는 미들웨어라는 개념이 존재함
    2. connect 함수와 userSelector 함수가 최적화가 잘되어 있음
    3. 리덕스는 글로벌 상태를 하나의 상태 객체로 관리하기 때문에 매번 Context를 만들 필요가 없음

4. ContextAPI 대신 리덕스를 써야 할 경우 써야 할때
    1. 규모가 큰 경우
    2. 비동기 작업이 잦은 경우
    3. 사용하기가 편하다고 느껴지는 경우

## 1.2 리덕스를 통한 상태관리 원리

리덕스를 사용하면 상태값을, 컴포넌트에 **종속시키지 않고**, 상태 관리를 컴포넌트의 **바깥에서 관리** 할 수 있게 됩니다.

1. 설정

    리덕스를 프로젝트에 적용하게 되면 이렇게 스토어 라는 녀석이 생깁니다. 스토어 안에는 프로젝트의 **상태에 관한 데이터들**이 담겨있습니다.
    
    ![리덕스 설정](../images\04\11\03 리덕스 설정.png)

2. 구독

    **컴포넌트는** 스토어에 **구독**을 합니다.
    구독을 하는 과정에서, 특정 함수가 스토어한테 전달이 됩니다.
    그리고 나중에 스토어의 상태값에 변동이 생긴다면 전달 받았던 함수를 호출해줍니다.
    
    ![리덕스 구독](../images\04\11\04 리덕스 구독.png)

3. 상태 변경

    1. dispatch

        이제 B 컴포넌트에서 어떤 이벤트가 생겨서, 상태를 변화 할 일이 생겼습니다.
        이 때 **dispatch** 라는 함수를 통하여 액션을 스토어한테 던져줍니다.
        **액션은 상태에 변화를 일으킬 때** 참조 할 수 있는 객체입니다.
        액션 객체는 필수적으로 type 라는 값을 가지고 있어야 합니다.
        
        예를들어 `{ type: 'INCREMENT' }` 이런 객체를 전달 받게 된다면, 리덕스 스토어는 아~ 상태에 값을 더해야 하는구나~ 하고 액션을 참조하게 됩니다.
        
        추가적으로, 상태값에 2를 더해야 한다면, 이러한 액션 객체를 만들게 됩니다: `{ type: 'INCREMENT', diff: 2 }`
        
        그러면, 나중에 이 diff 값을 참고해서 기존 값에 2를 더하게되겠죠.
        **type 를 제외한 값은 선택적(optional)** 인 값입니다.
        
        ![리덕스 상태 변경1](../images\04\11\05 리덕스 상태 변경1.png)

    2. 리듀서

        액션 객체를 받으면 전달받은 액션의 **타입에 따라** 어떻게 상태를 업데이트 해야 할지 정의를 해줘야겠죠?
        이러한 **업데이트 로직을 정의하는 함수를 리듀서**라고 부릅니다.
        이 함수는 나중에 우리가 직접 구현하게 됩니다.
        예를들어 type 이 INCREMENT 라는 액션이 들어오면 숫자를 더해주고, DECREMENT 라는 액션이 들어오면 숫자를 감소시키는 그런 작업을 여기서 하면 되죠.
        
        리듀서 함수는 두가지의 파라미터를 받습니다.
        
        - state: 현재 상태
        - action: 액션 객체
        
        그리고, 이 두가지 파라미터를 참조하여, 새로운 상태 객체를 만들어서 이를 반환합니다.
        
        ![리덕스 상태 변경2](../images\04\11\06 리덕스 상태 변경2.png)

4. 알림

    **상태에 변화가 생기면**, 이전에 컴포넌트가 스토어한테 구독 할 때 전달해줬었던 함수 listener 가 호출됩니다.
    이를 통하여 컴포넌트는 새로운 상태를 받게되고, 이에 따라 컴포넌트는 **리렌더링**을 하게 되죠.
    
    ![리덕스 알림](../images\04\11\07 리덕스 알림.png)

## 1.3 리덕스 키워드
1. 액션
2. 액션 생성함수
3. 리듀서
4. 스토어
5. 디스패치
6. 구독

## 1.4 리덕스 3가지 규칙
1. 하나의 애플리케이션 안에는 하나의 스토어가 존재
    1. 여러개도 허용은 하나, 권장하진 않음
2. 상태는 읽기전용
    1. 만약 배열이라면 값을 직접 건드리지 않고, 새로운 배열을 만들어 교체해야 함
3. 변화를 일으키는 함수, 리듀서는 순수함수여야 함
    1. 여기서 순수 함수란?
        1. 항상 같은 값이 나와야 함
            ```javascript
            function add(a, b) {
               return a + b;
            }
            ```
        2. 부수적 효과가 일어나면 안됨
            ```javascript
            let c = 20;
            function add3(a, b) {
              c = b;
              return a + b;
            }
            ```
        3. return 값으로만 소통
            ```javascript
            let obj1 = { val: 10 };
            function add4(obj, b) {
              obj.val += b;
            }
            ```
        4. 평가시점은 중요하지 않음
## 1.5 사용 준비
1. 라이브러리 설치
    ```javascript
       npm i redux
    ```
2. exercise.js 작성
    ```javascript
    import { createStore } from 'redux';
    
    // createStore는 스토어를 만들어주는 함수입니다.
    // 리액트 프로젝트에서는 단 하나의 스토어를 만듭니다.
    
    /* 리덕스에서 관리 할 상태 정의 */
    const initialState = {
      counter: 0,
      text: '',
      list: []
    };
    
    /* 액션 타입 정의 */
    // 액션 타입은 주로 대문자로 작성합니다.
    const INCREASE = 'INCREASE';
    const DECREASE = 'DECREASE';
    const CHANGE_TEXT = 'CHANGE_TEXT';
    const ADD_TO_LIST = 'ADD_TO_LIST';
    
    /* 액션 생성함수 정의 */
    // 액션 생성함수는 주로 camelCase 로 작성합니다.
    function increase() {
      return {
        type: INCREASE // 액션 객체에는 type 값이 필수입니다.
      };
    }
    
    // 화살표 함수로 작성하는 것이 더욱 코드가 간단하기에,
    // 이렇게 쓰는 것을 추천합니다.
    const decrease = () => ({
      type: DECREASE
    });
    
    const changeText = text => ({
      type: CHANGE_TEXT,
      text // 액션안에는 type 외에 추가적인 필드를 마음대로 넣을 수 있습니다.
    });
    
    const addToList = item => ({
      type: ADD_TO_LIST,
      item
    });
    
    /* 리듀서 만들기 */
    // 위 액션 생성함수들을 통해 만들어진 객체들을 참조하여
    // 새로운 상태를 만드는 함수를 만들어봅시다.
    // 주의: 리듀서에서는 불변성을 꼭 지켜줘야 합니다!
    
    function reducer(state = initialState, action) {
      // state 의 초깃값을 initialState 로 지정했습니다.
      switch (action.type) {
        case INCREASE:
          return {
            ...state,
            counter: state.counter + 1
          };
        case DECREASE:
          return {
            ...state,
            counter: state.counter - 1
          };
        case CHANGE_TEXT:
          return {
            ...state,
            text: action.text
          };
        case ADD_TO_LIST:
          return {
            ...state,
            list: state.list.concat(action.item)
          };
        default:
          return state;
      }
    }
    
    /* 스토어 만들기 */
    const store = createStore(reducer);
    
    console.log(store.getState()); // 현재 store 안에 들어있는 상태를 조회합니다.
    
    // 스토어안에 들어있는 상태가 바뀔 때 마다 호출되는 listener 함수
    const listener = () => {
      const state = store.getState();
      console.log(state);
    };
    
    const unsubscribe = store.subscribe(listener);
    // 구독을 해제하고 싶을 때는 unsubscribe() 를 호출하면 됩니다.
    
    // 액션들을 디스패치 해봅시다.
    store.dispatch(increase());
    store.dispatch(decrease());
    store.dispatch(changeText('안녕하세요'));
    store.dispatch(addToList({ id: 1, text: '와우' }));
    ```
   
## 1.6 리덕스 사용해보기

1. src/modules/counter.js
    - 리듀스 선언
    
    ```javascript
    /* 액션 타입 만들기 */
    // Ducks 패턴을 따를땐 액션의 이름에 접두사를 넣어주세요.
    // 이렇게 하면 다른 모듈과 액션 이름이 중복되는 것을 방지 할 수 있습니다.
    const SET_DIFF = 'counter/SET_DIFF';
    const INCREASE = 'counter/INCREASE';
    const DECREASE = 'counter/DECREASE';
    
    /* 액션 생성함수 만들기 */
    // 액션 생성함수를 만들고 export 키워드를 사용해서 내보내주세요.
    export const setDiff = diff => ({ type: SET_DIFF, diff });
    export const increase = () => ({ type: INCREASE });
    export const decrease = () => ({ type: DECREASE });
    
    /* 초기 상태 선언 */
    const initialState = {
      number: 0,
      diff: 1
    };
    
    /* 리듀서 선언 */
    // 리듀서는 export default 로 내보내주세요.
    export default function counter(state = initialState, action) {
      switch (action.type) {
        case SET_DIFF:
          return {
            ...state,
            diff: action.diff
          };
        case INCREASE:
          return {
            ...state,
            number: state.number + state.diff
          };
        case DECREASE:
          return {
            ...state,
            number: state.number - state.diff
          };
        default:
          return state;
      }
    }
    ```

2. src/modules/index.js
    ```javascript
    import { combineReducers } from 'redux';
    import counter from './counter';
    import todos from './todos';
    
    const rootReducer = combineReducers({
      counter,
      todos
    });
    
    export default rootReducer;
    ```

3. src/index.js
    - 스토어 생성 (설정완료 하면서 리듀스를 등록함)
    ```javascript
    import React from 'react';
    import ReactDOM from 'react-dom';
    import './index.css';
    import App from './App';
    import * as serviceWorker from './serviceWorker';
    import { createStore } from 'redux';
    import rootReducer from './modules';
    
    const store = createStore(rootReducer); // 스토어를 만듭니다.
    console.log(store.getState()); // 스토어의 상태를 확인해봅시다.
    
    ReactDOM.render(<App />, document.getElementById('root'));
    
    serviceWorker.unregister();
    ```

4. src/components/Counter.js
    ```javascript
    import React from 'react';
    
    function Counter({ number, diff, onIncrease, onDecrease, onSetDiff }) {
      const onChange = e => {
        // e.target.value 의 타입은 문자열이기 때문에 숫자로 변환해주어야 합니다.
        onSetDiff(parseInt(e.target.value, 10));
      };
      return (
        <div>
          <h1>{number}</h1>
          <div>
            <input type="number" value={diff} min="1" onChange={onChange} />
            <button onClick={onIncrease}>+</button>
            <button onClick={onDecrease}>-</button>
          </div>
        </div>
      );
    }
    
    export default Counter;
    ```

5. src/components/CounterContainer.js

    - dispatch 및 subscribe
        - subscribe를 직접 쓰진 않고, 제공하는 useSelector Hook을 사용하여 구독을 함
    
    ```javascript
    import React from 'react';
    import { useSelector, useDispatch } from 'react-redux';
    import Counter from '../components/Counter';
    import { increase, decrease, setDiff } from '../modules/counter';
    
    function CounterContainer() {
      // useSelector는 리덕스 스토어의 상태를 조회하는 Hook입니다.
      // state의 값은 store.getState() 함수를 호출했을 때 나타나는 결과물과 동일합니다.
      const { number, diff } = useSelector(state => ({
        number: state.counter.number,
        diff: state.counter.diff
      }));
    
      // useDispatch 는 리덕스 스토어의 dispatch 를 함수에서 사용 할 수 있게 해주는 Hook 입니다.
      const dispatch = useDispatch();
      // 각 액션들을 디스패치하는 함수들을 만드세요
      const onIncrease = () => dispatch(increase());
      const onDecrease = () => dispatch(decrease());
      const onSetDiff = diff => dispatch(setDiff(diff));
    
      return (
        <Counter
          // 상태와
          number={number}
          diff={diff}
          // 액션을 디스패치 하는 함수들을 props로 넣어줍니다.
          onIncrease={onIncrease}
          onDecrease={onDecrease}
          onSetDiff={onSetDiff}
        />
      );
    }
    
    export default CounterContainer;
    ```

## 1.7 개발자 도구 적용

![개발자 도구](../images\04\11\08 개발자 도구.png)

- 어떤 액션들이 디스패치 되고, 상태가 어떻게 편했는지 확인 가능 
- 심지어 직접 디스패치도 가능

1. redux-devtools-extension 설치
    ```javascript
    npm i redux-devtools-extension
    ```
   
2. index.js
    ```javascript
    import React from 'react';
    import ReactDOM from 'react-dom';
    import './index.css';
    import App from './App';
    import * as serviceWorker from './serviceWorker';
    import { createStore } from 'redux';
    import { Provider } from 'react-redux';
    import rootReducer from './modules';
    import { composeWithDevTools } from 'redux-devtools-extension'; // 리덕스 개발자 도구
    
    const store = createStore(rootReducer, composeWithDevTools()); // 스토어를 만듭니다.
    // composeWithDevTools 를 사용하여 리덕스 개발자 도구 활성화
    
    ReactDOM.render(
      <Provider store={store}>
        <App />
      </Provider>,
      document.getElementById('root')
    );

    serviceWorker.unregister();
    ```

# 2. 리덕스 미들웨어
1. 리덕스 순서
    1. `액션` -> `미들웨어` -> `리듀서` -> `스토어`
2. 리듀서에서 추가 작업이 가능하도록 할 수 있음
    1. 특정 조건에 따라 액션이 무시
    2. 액션을 콘솔에 출력하거나, 서버쪽에 로깅
    3. 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달
    4. 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생
    5. 특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행

## 2.1 리덕스 프로젝트 준비
1. 설치
    ```javascript
    npm i redux react-redux
    ```
## 2.2 미들웨어 만들기
## 2.3 redux-logger 사용
## 2.4 redux-thunk
## 2.5 redux-thunk 프로미스
## 2.6 api 재로딩
## 2.7 thunk 라우터 연동
## 2.8 redux-saga
## 2.9 redux-saga 프로미스
## 2.10 saga 라우터 연동
